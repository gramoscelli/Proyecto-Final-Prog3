En React (o JavaScript en general), tenés varias **opciones para consumir una API**, dependiendo de tus necesidades: simplicidad, manejo de errores, control sobre peticiones, o integración con estados globales. A continuación te explico las más usadas:

---

### ✅ **1. `fetch` (nativo de JavaScript)**

La opción más simple y sin instalar nada.

```js
useEffect(() => {
  fetch('https://api.ejemplo.com/tareas')
    .then(res => res.json())
    .then(data => setTasks(data))
    .catch(error => console.error(error));
}, []);
```

📌 Pros: nativo, liviano
📌 Contras: manejo de errores limitado, no aborta fácil peticiones

---

### 🚀 **2. `axios`**

Una librería muy popular para hacer peticiones HTTP.

```bash
npm install axios
```

```js
import axios from 'axios';

useEffect(() => {
  axios.get('https://api.ejemplo.com/tareas')
    .then(res => setTasks(res.data))
    .catch(err => console.error(err));
}, []);
```

📌 Pros: más amigable que `fetch`, interceptores, cancelación de requests
📌 Contras: requiere instalación

---

### 🧠 **3. `React Query` (hoy llamado TanStack Query)**

Ideal para manejar datos de APIs REST o GraphQL con cache, revalidación, etc.

```bash
npm install @tanstack/react-query
```

```js
import { useQuery } from '@tanstack/react-query';
import axios from 'axios';

function useTareas() {
  return useQuery({
    queryKey: ['tareas'],
    queryFn: async () => {
      const res = await axios.get('https://api.ejemplo.com/tareas');
      return res.data;
    },
  });
}
```

📌 Pros: manejo avanzado de cache, reintentos, loading, sincronización
📌 Contras: curva de aprendizaje un poco mayor

---

### 🌍 **4. `SWR` (de Vercel)**

Muy simple, auto-refresh y cache por defecto.

```bash
npm install swr
```

```js
import useSWR from 'swr';

const fetcher = (...args) => fetch(...args).then(res => res.json());

const { data, error, isLoading } = useSWR('https://api.ejemplo.com/tareas', fetcher);
```

📌 Pros: ideal para UIs reactivas, cache, revalidación
📌 Contras: no tan personalizable como React Query

---

### 🧩 **5. GraphQL + Apollo Client (si tu API es GraphQL)**

```bash
npm install @apollo/client graphql
```

```js
import { useQuery, gql } from '@apollo/client';

const GET_TASKS = gql`
  query {
    tasks {
      id
      title
    }
  }
`;

const { data, loading, error } = useQuery(GET_TASKS);
```

📌 Pros: integración perfecta con GraphQL, cache, estados
📌 Contras: solo para GraphQL APIs

---

### 📋 ¿Cuál conviene?

| Necesidad                        | Opción recomendada    |
| -------------------------------- | --------------------- |
| Simplicidad                      | `fetch` o `axios`     |
| Manejo avanzado de datos remotos | `React Query` o `SWR` |
| Integración con GraphQL          | `Apollo Client`       |
| Requiere interceptores o token   | `axios`               |
| Carga automática + cache         | `SWR` o `React Query` |

